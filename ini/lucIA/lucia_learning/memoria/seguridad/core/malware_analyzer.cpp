// malware_analyzer.cpp
// Analizador de malware de alto rendimiento para lucIA
// Detecta patrones maliciosos en archivos binarios y ejecutables

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <map>
#include <unordered_set>
#include <algorithm>
#include <cstring>
#include <cstdint>
#include <chrono>
#include <thread>
#include <mutex>

class MalwareAnalyzer {
private:
    std::unordered_set<std::string> malicious_signatures;
    std::unordered_set<std::string> suspicious_strings;
    std::map<std::string, int> file_hashes;
    std::mutex analysis_mutex;
    
    // Patrones de malware conocidos
    const std::vector<std::string> MALWARE_PATTERNS = {
        "CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory",
        "CreateProcess", "ShellExecute", "WinExec", "system(",
        "cmd.exe", "powershell", "regsvr32", "rundll32",
        "http://", "https://", "ftp://", "\\x", "\\u",
        "base64", "xor", "encrypt", "decrypt", "packer",
        "UPX", "ASPack", "PECompact", "Themida", "VMProtect"
    };
    
    // Strings sospechosos
    const std::vector<std::string> SUSPICIOUS_STRINGS = {
        "password", "admin", "root", "login", "auth",
        "keylogger", "backdoor", "trojan", "virus", "worm",
        "ransomware", "spyware", "adware", "botnet", "ddos",
        "exploit", "vulnerability", "overflow", "injection"
    };

public:
    MalwareAnalyzer() {
        initializeSignatures();
    }
    
    struct AnalysisResult {
        std::string filename;
        bool is_malicious;
        double threat_score;
        std::vector<std::string> detected_patterns;
        std::vector<std::string> suspicious_activities;
        std::string file_hash;
        std::string file_type;
        size_t file_size;
        std::chrono::system_clock::time_point analysis_time;
    };
    
    struct ThreatReport {
        std::string threat_type;
        int severity; // 1-10
        std::string description;
        std::vector<std::string> indicators;
        double confidence;
    };

private:
    void initializeSignatures() {
        for (const auto& pattern : MALWARE_PATTERNS) {
            malicious_signatures.insert(pattern);
        }
        
        for (const auto& str : SUSPICIOUS_STRINGS) {
            suspicious_strings.insert(str);
        }
    }
    
    std::string calculateFileHash(const std::vector<uint8_t>& data) {
        // Implementación simplificada de hash
        // En producción usaría SHA-256 o similar
        uint32_t hash = 0x811c9dc5;
        for (uint8_t byte : data) {
            hash ^= byte;
            hash *= 0x01000193;
        }
        return std::to_string(hash);
    }
    
    std::string detectFileType(const std::vector<uint8_t>& data) {
        if (data.size() < 4) return "unknown";
        
        // Detectar PE (Portable Executable)
        if (data[0] == 'M' && data[1] == 'Z') {
            return "PE/EXE";
        }
        
        // Detectar ELF
        if (data[0] == 0x7f && data[1] == 'E' && data[2] == 'L' && data[3] == 'F') {
            return "ELF";
        }
        
        // Detectar Mach-O
        if (data[0] == 0xfe && data[1] == 0xed && data[2] == 0xfa && data[3] == 0xce) {
            return "Mach-O";
        }
        
        // Detectar PDF
        if (data[0] == '%' && data[1] == 'P' && data[2] == 'D' && data[3] == 'F') {
            return "PDF";
        }
        
        // Detectar ZIP
        if (data[0] == 'P' && data[1] == 'K') {
            return "ZIP";
        }
        
        return "unknown";
    }
    
    std::vector<std::string> extractStrings(const std::vector<uint8_t>& data, size_t min_length = 4) {
        std::vector<std::string> strings;
        std::string current_string;
        
        for (uint8_t byte : data) {
            if (byte >= 32 && byte <= 126) { // Caracteres imprimibles ASCII
                current_string += static_cast<char>(byte);
            } else {
                if (current_string.length() >= min_length) {
                    strings.push_back(current_string);
                }
                current_string.clear();
            }
        }
        
        if (current_string.length() >= min_length) {
            strings.push_back(current_string);
        }
        
        return strings;
    }
    
    std::vector<std::string> findPatterns(const std::vector<std::string>& strings) {
        std::vector<std::string> found_patterns;
        
        for (const auto& str : strings) {
            std::string lower_str = str;
            std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);
            
            for (const auto& pattern : malicious_signatures) {
                if (lower_str.find(pattern) != std::string::npos) {
                    found_patterns.push_back(pattern);
                }
            }
        }
        
        return found_patterns;
    }
    
    std::vector<std::string> findSuspiciousStrings(const std::vector<std::string>& strings) {
        std::vector<std::string> found_suspicious;
        
        for (const auto& str : strings) {
            std::string lower_str = str;
            std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);
            
            for (const auto& suspicious : suspicious_strings) {
                if (lower_str.find(suspicious) != std::string::npos) {
                    found_suspicious.push_back(suspicious);
                }
            }
        }
        
        return found_suspicious;
    }
    
    double calculateThreatScore(const std::vector<std::string>& patterns, 
                               const std::vector<std::string>& suspicious,
                               const std::string& file_type,
                               size_t file_size) {
        double score = 0.0;
        
        // Puntuación por patrones maliciosos
        score += patterns.size() * 20.0;
        
        // Puntuación por strings sospechosos
        score += suspicious.size() * 10.0;
        
        // Puntuación por tipo de archivo
        if (file_type == "PE/EXE" || file_type == "ELF") {
            score += 15.0;
        } else if (file_type == "PDF" || file_type == "ZIP") {
            score += 5.0;
        }
        
        // Puntuación por tamaño (archivos muy pequeños o muy grandes son sospechosos)
        if (file_size < 1024 || file_size > 100 * 1024 * 1024) {
            score += 10.0;
        }
        
        return std::min(score, 100.0);
    }
    
    bool detectPackedExecutable(const std::vector<uint8_t>& data) {
        // Detectar ejecutables empaquetados
        std::vector<std::string> strings = extractStrings(data);
        
        for (const auto& str : strings) {
            std::string lower_str = str;
            std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);
            
            if (lower_str.find("upx") != std::string::npos ||
                lower_str.find("aspack") != std::string::npos ||
                lower_str.find("pecompact") != std::string::npos) {
                return true;
            }
        }
        
        return false;
    }
    
    bool detectObfuscation(const std::vector<uint8_t>& data) {
        // Detectar técnicas de ofuscación
        std::vector<std::string> strings = extractStrings(data);
        
        for (const auto& str : strings) {
            std::string lower_str = str;
            std::transform(lower_str.begin(), lower_str.end(), lower_str.begin(), ::tolower);
            
            if (lower_str.find("\\x") != std::string::npos ||
                lower_str.find("\\u") != std::string::npos ||
                lower_str.find("base64") != std::string::npos ||
                lower_str.find("xor") != std::string::npos) {
                return true;
            }
        }
        
        return false;
    }

public:
    AnalysisResult analyzeFile(const std::string& filename) {
        std::lock_guard<std::mutex> lock(analysis_mutex);
        
        AnalysisResult result;
        result.filename = filename;
        result.analysis_time = std::chrono::system_clock::now();
        
        // Leer archivo
        std::ifstream file(filename, std::ios::binary);
        if (!file.is_open()) {
            result.is_malicious = false;
            result.threat_score = 0.0;
            return result;
        }
        
        std::vector<uint8_t> data((std::istreambuf_iterator<char>(file)),
                                  std::istreambuf_iterator<char>());
        file.close();
        
        result.file_size = data.size();
        result.file_type = detectFileType(data);
        result.file_hash = calculateFileHash(data);
        
        // Extraer strings
        std::vector<std::string> strings = extractStrings(data);
        
        // Buscar patrones maliciosos
        result.detected_patterns = findPatterns(strings);
        
        // Buscar strings sospechosos
        result.suspicious_activities = findSuspiciousStrings(strings);
        
        // Detectar empaquetado
        if (detectPackedExecutable(data)) {
            result.suspicious_activities.push_back("PACKED_EXECUTABLE");
        }
        
        // Detectar ofuscación
        if (detectObfuscation(data)) {
            result.suspicious_activities.push_back("OBFUSCATED_CODE");
        }
        
        // Calcular puntuación de amenaza
        result.threat_score = calculateThreatScore(
            result.detected_patterns,
            result.suspicious_activities,
            result.file_type,
            result.file_size
        );
        
        // Determinar si es malicioso
        result.is_malicious = (result.threat_score > 50.0);
        
        return result;
    }
    
    std::vector<ThreatReport> generateThreatReport(const AnalysisResult& result) {
        std::vector<ThreatReport> reports;
        
        if (result.is_malicious) {
            ThreatReport report;
            report.threat_type = "MALWARE_DETECTED";
            report.severity = static_cast<int>(result.threat_score / 10.0);
            report.description = "Archivo potencialmente malicioso detectado";
            report.confidence = result.threat_score / 100.0;
            
            for (const auto& pattern : result.detected_patterns) {
                report.indicators.push_back("Patrón: " + pattern);
            }
            
            for (const auto& activity : result.suspicious_activities) {
                report.indicators.push_back("Actividad: " + activity);
            }
            
            reports.push_back(report);
        }
        
        return reports;
    }
    
    void addCustomSignature(const std::string& signature) {
        std::lock_guard<std::mutex> lock(analysis_mutex);
        malicious_signatures.insert(signature);
    }
    
    void removeSignature(const std::string& signature) {
        std::lock_guard<std::mutex> lock(analysis_mutex);
        malicious_signatures.erase(signature);
    }
    
    std::vector<std::string> getSignatures() {
        std::lock_guard<std::mutex> lock(analysis_mutex);
        return std::vector<std::string>(malicious_signatures.begin(), malicious_signatures.end());
    }
};

// Función principal para integración con lucIA
extern "C" const char* analyzeMalwareSecurity() {
    static std::string result;
    
    MalwareAnalyzer analyzer;
    
    // Simular análisis de archivo
    AnalysisResult analysis = analyzer.analyzeFile("test_file.exe");
    
    if (analysis.is_malicious) {
        result = "Malware detectado: " + std::to_string(analysis.threat_score) + "% de amenaza";
    } else {
        result = "Archivo seguro. Puntuación: " + std::to_string(analysis.threat_score);
    }
    
    return result.c_str();
}

// Función de ejemplo para uso directo
int main() {
    MalwareAnalyzer analyzer;
    
    std::cout << "Analizador de Malware para lucIA" << std::endl;
    std::cout << "=================================" << std::endl;
    
    // Ejemplo de análisis
    const char* result = analyzeMalwareSecurity();
    std::cout << "Resultado: " << result << std::endl;
    
    return 0;
} 