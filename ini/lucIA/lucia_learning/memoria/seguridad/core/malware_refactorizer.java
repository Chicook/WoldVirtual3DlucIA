// malware_refactorizer.java
// Sistema de refactorización de malware para lucIA
// Convierte código malicioso en código seguro y útil

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.*;
import java.security.*;
import java.util.concurrent.*;

public class MalwareRefactorizer {
    
    // Estructura para patrones de malware y sus refactorizaciones
    private static class MalwarePattern {
        String pattern;
        String replacement;
        String description;
        int severity;
        String category;
        
        MalwarePattern(String pattern, String replacement, String description, int severity, String category) {
            this.pattern = pattern;
            this.replacement = replacement;
            this.description = description;
            this.severity = severity;
            this.category = category;
        }
    }
    
    // Estructura para resultados de refactorización
    public static class RefactorizationResult {
        public String originalCode;
        public String refactoredCode;
        public List<String> changes;
        public double safetyScore;
        public boolean isSafe;
        public List<String> warnings;
        public Map<String, Integer> patternReplacements;
        
        public RefactorizationResult() {
            this.changes = new ArrayList<>();
            this.warnings = new ArrayList<>();
            this.patternReplacements = new HashMap<>();
        }
    }
    
    // Patrones de malware conocidos y sus refactorizaciones
    private static final List<MalwarePattern> MALWARE_PATTERNS = Arrays.asList(
        // Patrones de ejecución de código dinámico
        new MalwarePattern(
            "eval\\s*\\(([^)]+)\\)",
            "// EVAL_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de eval() - Reemplazado con logging",
            9, "code_execution"
        ),
        new MalwarePattern(
            "exec\\s*\\(([^)]+)\\)",
            "// EXEC_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de exec() - Reemplazado con logging",
            9, "code_execution"
        ),
        new MalwarePattern(
            "os\\.system\\s*\\(([^)]+)\\)",
            "// SYSTEM_CALL_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de os.system() - Reemplazado con logging",
            8, "system_access"
        ),
        new MalwarePattern(
            "subprocess\\.call\\s*\\(([^)]+)\\)",
            "// SUBPROCESS_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de subprocess.call() - Reemplazado con logging",
            8, "system_access"
        ),
        
        // Patrones de ofuscación
        new MalwarePattern(
            "base64\\.b64decode\\s*\\(([^)]+)\\)",
            "// BASE64_DECODE_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de base64.b64decode() - Reemplazado con logging",
            7, "obfuscation"
        ),
        new MalwarePattern(
            "marshal\\.loads\\s*\\(([^)]+)\\)",
            "// MARSHAL_LOAD_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de marshal.loads() - Reemplazado con logging",
            8, "code_execution"
        ),
        new MalwarePattern(
            "compile\\s*\\(([^)]+)\\)",
            "// COMPILE_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de compile() - Reemplazado con logging",
            7, "code_execution"
        ),
        
        // Patrones de acceso al sistema
        new MalwarePattern(
            "__import__\\s*\\(([^)]+)\\)",
            "// IMPORT_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de __import__() - Reemplazado con logging",
            6, "system_access"
        ),
        new MalwarePattern(
            "globals\\s*\\(\\s*\\)",
            "// GLOBALS_REMOVED - Reemplazado con logging seguro",
            "Eliminación de globals() - Reemplazado con logging",
            7, "system_access"
        ),
        new MalwarePattern(
            "locals\\s*\\(\\s*\\)",
            "// LOCALS_REMOVED - Reemplazado con logging seguro",
            "Eliminación de locals() - Reemplazado con logging",
            7, "system_access"
        ),
        
        // Patrones de acceso a atributos dinámicos
        new MalwarePattern(
            "getattr\\s*\\(([^)]+)\\)",
            "// GETATTR_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de getattr() - Reemplazado con logging",
            6, "system_access"
        ),
        new MalwarePattern(
            "setattr\\s*\\(([^)]+)\\)",
            "// SETATTR_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de setattr() - Reemplazado con logging",
            6, "system_access"
        ),
        
        // Patrones de acceso a archivos peligrosos
        new MalwarePattern(
            "open\\s*\\(([^)]+),\\s*['\"]w['\"]\\)",
            "// FILE_WRITE_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de escritura de archivos - Reemplazado con logging",
            5, "file_access"
        ),
        new MalwarePattern(
            "os\\.remove\\s*\\(([^)]+)\\)",
            "// FILE_DELETE_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de eliminación de archivos - Reemplazado con logging",
            6, "file_access"
        ),
        
        // Patrones de red peligrosos
        new MalwarePattern(
            "urllib\\.request\\.urlopen\\s*\\(([^)]+)\\)",
            "// NETWORK_ACCESS_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de acceso a red - Reemplazado con logging",
            5, "network_access"
        ),
        new MalwarePattern(
            "requests\\.get\\s*\\(([^)]+)\\)",
            "// HTTP_REQUEST_REMOVED: $1 - Reemplazado con logging seguro",
            "Eliminación de peticiones HTTP - Reemplazado con logging",
            5, "network_access"
        ),
        
        // Patrones de ofuscación de strings
        new MalwarePattern(
            "\\\\x([0-9a-fA-F]{2})",
            "// HEX_ESCAPE_REMOVED: \\\\x$1 - Reemplazado con logging seguro",
            "Eliminación de escapes hexadecimales - Reemplazado con logging",
            4, "obfuscation"
        ),
        new MalwarePattern(
            "\\\\u([0-9a-fA-F]{4})",
            "// UNICODE_ESCAPE_REMOVED: \\\\u$1 - Reemplazado con logging seguro",
            "Eliminación de escapes Unicode - Reemplazado con logging",
            4, "obfuscation"
        ),
        
        // Patrones de acceso al registro (Windows)
        new MalwarePattern(
            "winreg\\.",
            "// REGISTRY_ACCESS_REMOVED - Reemplazado con logging seguro",
            "Eliminación de acceso al registro - Reemplazado con logging",
            6, "system_access"
        ),
        
        // Patrones de acceso a procesos
        new MalwarePattern(
            "psutil\\.",
            "// PROCESS_ACCESS_REMOVED - Reemplazado con logging seguro",
            "Eliminación de acceso a procesos - Reemplazado con logging",
            6, "system_access"
        )
    );
    
    // Refactorizar código malicioso
    public RefactorizationResult refactorMaliciousCode(String originalCode) {
        RefactorizationResult result = new RefactorizationResult();
        result.originalCode = originalCode;
        result.refactoredCode = originalCode;
        
        // Añadir encabezado de seguridad
        result.refactoredCode = addSecurityHeader(result.refactoredCode);
        
        // Aplicar patrones de refactorización
        for (MalwarePattern pattern : MALWARE_PATTERNS) {
            result = applyPattern(result, pattern);
        }
        
        // Añadir logging de seguridad
        result.refactoredCode = addSecurityLogging(result.refactoredCode);
        
        // Añadir validaciones de seguridad
        result.refactoredCode = addSecurityValidations(result.refactoredCode);
        
        // Calcular puntuación de seguridad
        result.safetyScore = calculateSafetyScore(result);
        result.isSafe = result.safetyScore > 0.7;
        
        // Generar advertencias
        generateWarnings(result);
        
        return result;
    }
    
    // Aplicar patrón de refactorización
    private RefactorizationResult applyPattern(RefactorizationResult result, MalwarePattern pattern) {
        Pattern regex = Pattern.compile(pattern.pattern, Pattern.CASE_INSENSITIVE);
        Matcher matcher = regex.matcher(result.refactoredCode);
        
        int replacementCount = 0;
        StringBuffer sb = new StringBuffer();
        
        while (matcher.find()) {
            String replacement = pattern.replacement;
            if (matcher.groupCount() > 0) {
                replacement = replacement.replace("$1", matcher.group(1));
            }
            
            matcher.appendReplacement(sb, Matcher.quoteReplacement(replacement));
            replacementCount++;
            
            // Añadir cambio a la lista
            result.changes.add(String.format("Patrón '%s' reemplazado: %s", 
                pattern.description, matcher.group(0)));
        }
        
        matcher.appendTail(sb);
        result.refactoredCode = sb.toString();
        
        // Actualizar contador de reemplazos
        result.patternReplacements.put(pattern.category, 
            result.patternReplacements.getOrDefault(pattern.category, 0) + replacementCount);
        
        return result;
    }
    
    // Añadir encabezado de seguridad
    private String addSecurityHeader(String code) {
        String header = """
            # =============================================================================
            # CÓDIGO REFACTORIZADO POR LUCIA SECURITY SYSTEM
            # =============================================================================
            # Este código ha sido analizado y refactorizado para eliminar amenazas de seguridad
            # Fecha de refactorización: """ + new java.util.Date() + """
            # Sistema: LucIA Security Refactorizer v1.0
            # =============================================================================
            
            import logging
            import sys
            from datetime import datetime
            
            # Configurar logging de seguridad
            security_logger = logging.getLogger('security_refactorized')
            security_logger.setLevel(logging.INFO)
            
            def log_security_event(event_type, details, severity="INFO"):
                \"\"\"Función para logging de eventos de seguridad\"\"\"
                timestamp = datetime.now().isoformat()
                message = f"[SECURITY] {timestamp} - {event_type}: {details}"
                security_logger.info(message)
                print(f"[SECURITY_LOG] {message}")
            
            # Función para validación de entrada segura
            def validate_input(input_data, max_length=1000):
                \"\"\"Validar entrada de datos de forma segura\"\"\"
                if not isinstance(input_data, str):
                    log_security_event("INPUT_VALIDATION", "Tipo de entrada inválido", "WARNING")
                    return False
                if len(input_data) > max_length:
                    log_security_event("INPUT_VALIDATION", "Entrada demasiado larga", "WARNING")
                    return False
                return True
            
            # Función para sanitización de datos
            def sanitize_data(data):
                \"\"\"Sanitizar datos de entrada\"\"\"
                if isinstance(data, str):
                    # Eliminar caracteres peligrosos
                    dangerous_chars = ['<', '>', '"', "'", '&', ';', '|', '`', '$', '(', ')']
                    for char in dangerous_chars:
                        data = data.replace(char, '')
                return data
            
            """;
        
        return header + "\n" + code;
    }
    
    // Añadir logging de seguridad
    private String addSecurityLogging(String code) {
        // Añadir logging al final del código
        String footer = """
            
            # =============================================================================
            # LOGGING DE SEGURIDAD AUTOMÁTICO
            # =============================================================================
            
            # Log de finalización de ejecución
            log_security_event("EXECUTION_COMPLETE", "Código refactorizado ejecutado exitosamente", "INFO")
            
            # Verificación de integridad
            try:
                # Verificar que no hay operaciones peligrosas
                dangerous_operations = ['eval', 'exec', 'os.system', 'subprocess', 'base64.b64decode']
                for op in dangerous_operations:
                    if op in str(locals()) or op in str(globals()):
                        log_security_event("INTEGRITY_CHECK", f"Operación peligrosa detectada: {op}", "ERROR")
                        raise SecurityException(f"Operación peligrosa no permitida: {op}")
                
                log_security_event("INTEGRITY_CHECK", "Verificación de integridad completada", "INFO")
                
            except Exception as e:
                log_security_event("INTEGRITY_CHECK", f"Error en verificación: {str(e)}", "ERROR")
            
            # =============================================================================
            """;
        
        return code + footer;
    }
    
    // Añadir validaciones de seguridad
    private String addSecurityValidations(String code) {
        // Buscar funciones y añadir validaciones
        Pattern functionPattern = Pattern.compile("def\\s+(\\w+)\\s*\\(");
        Matcher matcher = functionPattern.matcher(code);
        
        StringBuffer sb = new StringBuffer();
        while (matcher.find()) {
            String functionName = matcher.group(1);
            String validation = String.format("""
                
                # Validación de seguridad para función %s
                def validate_%s_security(*args, **kwargs):
                    \"\"\"Validación de seguridad para %s\"\"\"
                    log_security_event("FUNCTION_CALL", "Llamada a función: %s", "INFO")
                    
                    # Validar argumentos
                    for i, arg in enumerate(args):
                        if isinstance(arg, str) and len(arg) > 1000:
                            log_security_event("ARGUMENT_VALIDATION", 
                                f"Argumento {i} demasiado largo en %s", "WARNING")
                    
                    # Validar keywords
                    for key, value in kwargs.items():
                        if isinstance(value, str) and len(value) > 1000:
                            log_security_event("ARGUMENT_VALIDATION", 
                                f"Keyword {key} demasiado largo en %s", "WARNING")
                    
                    return True
                
                """, functionName, functionName, functionName, functionName, functionName, functionName, functionName);
            
            matcher.appendReplacement(sb, matcher.group(0) + validation);
        }
        matcher.appendTail(sb);
        
        return sb.toString();
    }
    
    // Calcular puntuación de seguridad
    private double calculateSafetyScore(RefactorizationResult result) {
        double score = 1.0; // Puntuación inicial perfecta
        
        // Reducir puntuación por cada patrón reemplazado
        for (Map.Entry<String, Integer> entry : result.patternReplacements.entrySet()) {
            String category = entry.getKey();
            int count = entry.getValue();
            
            switch (category) {
                case "code_execution":
                    score -= count * 0.15;
                    break;
                case "system_access":
                    score -= count * 0.12;
                    break;
                case "file_access":
                    score -= count * 0.08;
                    break;
                case "network_access":
                    score -= count * 0.06;
                    break;
                case "obfuscation":
                    score -= count * 0.05;
                    break;
            }
        }
        
        // Añadir puntos por mejoras de seguridad
        if (result.refactoredCode.contains("log_security_event")) {
            score += 0.1;
        }
        if (result.refactoredCode.contains("validate_input")) {
            score += 0.1;
        }
        if (result.refactoredCode.contains("sanitize_data")) {
            score += 0.1;
        }
        
        return Math.max(0.0, Math.min(1.0, score));
    }
    
    // Generar advertencias
    private void generateWarnings(RefactorizationResult result) {
        if (result.safetyScore < 0.5) {
            result.warnings.add("ADVERTENCIA CRÍTICA: El código aún presenta riesgos significativos de seguridad");
        }
        
        if (result.safetyScore < 0.7) {
            result.warnings.add("ADVERTENCIA: Se recomienda revisión manual adicional del código");
        }
        
        for (Map.Entry<String, Integer> entry : result.patternReplacements.entrySet()) {
            if (entry.getValue() > 5) {
                result.warnings.add(String.format("ADVERTENCIA: Muchos patrones de %s detectados (%d)", 
                    entry.getKey(), entry.getValue()));
            }
        }
        
        if (result.changes.size() > 10) {
            result.warnings.add("ADVERTENCIA: Se realizaron muchas modificaciones. Verificar funcionalidad.");
        }
    }
    
    // Refactorizar archivo completo
    public RefactorizationResult refactorFile(String filePath) throws IOException {
        String content = new String(Files.readAllBytes(Paths.get(filePath)));
        return refactorMaliciousCode(content);
    }
    
    // Guardar código refactorizado
    public void saveRefactoredCode(RefactorizationResult result, String outputPath) throws IOException {
        Files.write(Paths.get(outputPath), result.refactoredCode.getBytes());
    }
    
    // Generar reporte de refactorización
    public String generateRefactorizationReport(RefactorizationResult result) {
        StringBuilder report = new StringBuilder();
        report.append("=== REPORTE DE REFACTORIZACIÓN DE SEGURIDAD ===\n\n");
        report.append("Puntuación de seguridad: ").append(String.format("%.2f", result.safetyScore)).append("\n");
        report.append("Es seguro: ").append(result.isSafe ? "SÍ" : "NO").append("\n");
        report.append("Cambios realizados: ").append(result.changes.size()).append("\n\n");
        
        report.append("=== PATRONES REEMPLAZADOS ===\n");
        for (Map.Entry<String, Integer> entry : result.patternReplacements.entrySet()) {
            report.append(entry.getKey()).append(": ").append(entry.getValue()).append(" reemplazos\n");
        }
        report.append("\n");
        
        report.append("=== CAMBIOS DETALLADOS ===\n");
        for (String change : result.changes) {
            report.append("- ").append(change).append("\n");
        }
        report.append("\n");
        
        if (!result.warnings.isEmpty()) {
            report.append("=== ADVERTENCIAS ===\n");
            for (String warning : result.warnings) {
                report.append("⚠ ").append(warning).append("\n");
            }
            report.append("\n");
        }
        
        report.append("=== RECOMENDACIONES ===\n");
        if (result.safetyScore < 0.7) {
            report.append("- Revisar manualmente el código refactorizado\n");
            report.append("- Probar en entorno aislado antes de producción\n");
            report.append("- Considerar reescritura completa si es necesario\n");
        } else {
            report.append("- El código es seguro para uso en entorno controlado\n");
            report.append("- Monitorear comportamiento durante ejecución\n");
        }
        
        return report.toString();
    }
    
    // Función principal para integración con lucIA
    public static String refactorMalwareForLucia(String maliciousCode) {
        try {
            MalwareRefactorizer refactorizer = new MalwareRefactorizer();
            RefactorizationResult result = refactorizer.refactorMaliciousCode(maliciousCode);
            
            return String.format("""
                Refactorización completada:
                - Puntuación de seguridad: %.2f
                - Es seguro: %s
                - Cambios realizados: %d
                - Patrones reemplazados: %s
                """, 
                result.safetyScore,
                result.isSafe ? "SÍ" : "NO",
                result.changes.size(),
                result.patternReplacements.toString()
            );
            
        } catch (Exception e) {
            return "Error en refactorización: " + e.getMessage();
        }
    }
} 