#!/usr/bin/env python3
"""
LucIA Core - Sistema Principal de LucIA
Versi√≥n para auto-an√°lisis y mejora (sin claves de API)
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
import json
import re

from memory import MemoryManager, MemoryEntry, ConversationEntry
from paraphraser import Paraphraser, ParaphraseConfig, PersonalityType
from api_manager import APIManager, APIResponse
import config

logger = logging.getLogger(__name__)

@dataclass
class ChatResponse:
    """Respuesta del chat"""
    original_response: str
    paraphrased_response: str
    source_api: str
    confidence: float
    processing_time: float
    keywords: List[str]
    context: str
    used_memory: bool = False

class LucIACore:
    """N√∫cleo principal de LucIA"""
    
    def __init__(self, 
                 name: str = None,
                 personality: PersonalityType = None,
                 enable_memory: bool = True,
                 enable_paraphrasing: bool = True):
        
        # Configuraci√≥n
        self.name = name or config.platform.ai_name
        self.personality = personality or PersonalityType.FRIENDLY
        self.enable_memory = enable_memory
        self.enable_paraphrasing = enable_paraphrasing
        
        # Componentes principales
        self.memory_manager = MemoryManager() if enable_memory else None
        self.paraphraser = Paraphraser(ParaphraseConfig(
            personality=self.personality,
            confidence_threshold=config.memory.paraphrase_confidence
        )) if enable_paraphrasing else None
        
        # Estado del sistema
        self.conversation_history: List[ConversationEntry] = []
        self.stats = {
            "total_requests": 0,
            "api_requests": 0,
            "memory_requests": 0,
            "total_processing_time": 0.0,
            "average_confidence": 0.0
        }
        
        self._show_startup_info()
    
    def _show_startup_info(self):
        """Muestra informaci√≥n de inicio"""
        logger.info(f"üåü {self.name} inicializado")
        logger.info(f"üé≠ Personalidad: {self.personality.value}")
        logger.info(f"üß† Memoria: {'Activada' if self.enable_memory else 'Desactivada'}")
        logger.info(f"üîÑ Parafraseo: {'Activado' if self.enable_paraphrasing else 'Desactivado'}")
        logger.info(f"üåê Plataforma: {config.platform.platform_name}")
        
    async def chat(self, prompt: str, context: List[str] = None) -> ChatResponse:
        """Procesa una conversaci√≥n con el usuario"""
        start_time = datetime.now()
        self.stats["total_requests"] += 1
        
        try:
            # Extraer palabras clave
            keywords = self._extract_keywords(prompt)
            
            # Obtener contexto de conversaci√≥n
            conversation_context = self._get_conversation_context()
            if context:
                conversation_context.extend(context)
            
            # Intentar obtener respuesta de API
            api_response = await self._get_api_response(prompt, conversation_context)
            
            if api_response:
                # Usar respuesta de API
                response = api_response.response
                source_api = api_response.source_api
                confidence = api_response.confidence
                used_memory = False
            else:
                # Intentar obtener respuesta de memoria
                memory_entry = await self._get_memory_response(prompt)
                
                if memory_entry:
                    response = memory_entry.paraphrased_response
                    source_api = f"{memory_entry.source_api}_memory"
                    confidence = memory_entry.confidence * 0.9  # Ligeramente menor confianza
                    used_memory = True
                else:
                    # Generar respuesta local
                    response = self._generate_local_response(prompt)
                    source_api = "local"
                    confidence = 0.7
                    used_memory = False
            
            # Parafrasear respuesta si est√° habilitado
            paraphrased_response = response
            if self.enable_paraphrasing and self.paraphraser:
                paraphrased_response = self._paraphrase_response(response)
            
            # Calcular tiempo de procesamiento
            processing_time = (datetime.now() - start_time).total_seconds()
            
            # Crear respuesta del chat
            chat_response = ChatResponse(
                original_response=response,
                paraphrased_response=paraphrased_response,
                source_api=source_api,
                confidence=confidence,
                processing_time=processing_time,
                keywords=keywords,
                context=json.dumps(conversation_context),
                used_memory=used_memory
            )
            
            # Almacenar en memoria
            self._store_response_in_memory(prompt, chat_response)
            
            # Actualizar estad√≠sticas
            self._update_stats(chat_response)
            
            return chat_response
            
        except Exception as e:
            logger.error(f"Error en chat: {e}")
            processing_time = (datetime.now() - start_time).total_seconds()
            
            return ChatResponse(
                original_response="Lo siento, hubo un error procesando tu solicitud.",
                paraphrased_response="Lo siento, hubo un error procesando tu solicitud.",
                source_api="error",
                confidence=0.0,
                processing_time=processing_time,
                keywords=[],
                context="",
                used_memory=False
            )
    
    async def _get_api_response(self, prompt: str, context: List[str] = None) -> Optional[APIResponse]:
        """Obtiene respuesta de API externa"""
        if not self.memory_manager:
            return None
            
        try:
            async with APIManager(self.memory_manager) as api_manager:
                return await api_manager.get_response(prompt, context)
        except Exception as e:
            logger.error(f"Error obteniendo respuesta de API: {e}")
            return None
    
    async def _get_memory_response(self, prompt: str) -> Optional[MemoryEntry]:
        """Obtiene respuesta desde la memoria"""
        if not self.memory_manager:
            return None
            
        try:
            return self.memory_manager.generate_response_from_memory(prompt, self.paraphraser)
        except Exception as e:
            logger.error(f"Error obteniendo respuesta de memoria: {e}")
            return None
    
    def _paraphrase_response(self, response: str) -> str:
        """Parafrasea una respuesta"""
        if not self.paraphraser:
            return response
            
        try:
            return self.paraphraser.paraphrase_from_memory(response)
        except Exception as e:
            logger.error(f"Error parafraseando respuesta: {e}")
            return response
        
    def _extract_keywords(self, text: str) -> List[str]:
        """Extrae palabras clave del texto"""
        # Palabras de parada en espa√±ol
        stop_words = {
            "el", "la", "de", "que", "y", "a", "en", "un", "es", "se", "no", "te", "lo", "le", "da", "su", "por", "son", "con", "para", "al", "del", "los", "las", "una", "como", "pero", "sus", "me", "hasta", "hay", "donde", "han", "quien", "est√°n", "estado", "desde", "todo", "nos", "durante", "todos", "uno", "les", "ni", "contra", "otros", "ese", "eso", "ante", "ellos", "e", "esto", "m√≠", "antes", "algunos", "qu√©", "unos", "yo", "otro", "otras", "otra", "√©l", "tanto", "esa", "estos", "mucho", "quienes", "nada", "muchos", "cual", "poco", "ella", "estar", "estas", "algunas", "algo", "nosotros", "mi", "mis", "t√∫", "te", "ti", "tu", "tus", "ellas", "nosotras", "vosotros", "vosotras", "os", "m√≠o", "m√≠a", "m√≠os", "m√≠as", "tuyo", "tuya", "tuyos", "tuyas", "suyo", "suya", "suyos", "suyas", "nuestro", "nuestra", "nuestros", "nuestras", "vuestro", "vuestra", "vuestros", "vuestras", "esos", "esas", "estoy", "est√°s", "est√°", "estamos", "est√°is", "est√°n", "est√©", "est√©s", "estemos", "est√©is", "est√©n", "estar√©", "estar√°s", "estar√°", "estaremos", "estar√©is", "estar√°n", "estar√≠a", "estar√≠as", "estar√≠amos", "estar√≠ais", "estar√≠an", "estaba", "estabas", "est√°bamos", "estabais", "estaban", "estuve", "estuviste", "estuvo", "estuvimos", "estuvisteis", "estuvieron", "estuviera", "estuvieras", "estuvi√©ramos", "estuvierais", "estuvieran", "estuviese", "estuvieses", "estuvi√©semos", "estuvieseis", "estuviesen", "estando", "estado", "estada", "estados", "estadas", "estad", "he", "has", "ha", "hemos", "hab√©is", "han", "haya", "hayas", "hayamos", "hay√°is", "hayan", "habr√©", "habr√°s", "habr√°", "habremos", "habr√©is", "habr√°n", "habr√≠a", "habr√≠as", "habr√≠amos", "habr√≠ais", "habr√≠an", "hab√≠a", "hab√≠as", "hab√≠amos", "hab√≠ais", "hab√≠an", "hube", "hubiste", "hubo", "hubimos", "hubisteis", "hubieron", "hubiera", "hubieras", "hubi√©ramos", "hubierais", "hubieran", "hubiese", "hubieses", "hubi√©semos", "hubieseis", "hubiesen", "habiendo", "habido", "habida", "habidos", "habidas", "soy", "eres", "es", "somos", "sois", "son", "sea", "seas", "seamos", "se√°is", "sean", "ser√©", "ser√°s", "ser√°", "seremos", "ser√©is", "ser√°n", "ser√≠a", "ser√≠as", "ser√≠amos", "ser√≠ais", "ser√≠an", "era", "eras", "√©ramos", "erais", "eran", "fui", "fuiste", "fue", "fuimos", "fuisteis", "fueron", "fuera", "fueras", "fu√©ramos", "fuerais", "fueran", "fuese", "fueses", "fu√©semos", "fueseis", "fuesen", "sintiendo", "sentido", "sentida", "sentidos", "sentidas", "siente", "sentid", "tengo", "tienes", "tiene", "tenemos", "ten√©is", "tienen", "tenga", "tengas", "tengamos", "teng√°is", "tengan", "tendr√©", "tendr√°s", "tendr√°", "tendremos", "tendr√©is", "tendr√°n", "tendr√≠a", "tendr√≠as", "tendr√≠amos", "tendr√≠ais", "tendr√≠an", "ten√≠a", "ten√≠as", "ten√≠amos", "ten√≠ais", "ten√≠an", "tuve", "tuviste", "tuvo", "tuvimos", "tuvisteis", "tuvieron", "tuviera", "tuvieras", "tuvi√©ramos", "tuvierais", "tuvieran", "tuviese", "tuvieses", "tuvi√©semos", "tuvieseis", "tuviesen", "teniendo", "tenido", "tenida", "tenidos", "tenidas", "tened", "m√°s", "pero", "si", "yo", "√©l", "ella", "nosotros", "vosotros", "ellos", "ellas", "este", "esta", "estos", "estas", "ese", "esa", "esos", "esas", "aquel", "aquella", "aquellos", "aquellas", "ser", "estar", "tener", "hacer", "decir", "poder", "ir", "ver", "dar", "saber", "querer", "llegar", "pasar", "deber", "poner", "parecer", "quedar", "creer", "hablar", "llevar", "dejar", "seguir", "encontrar", "llamar", "venir", "pensar", "salir", "volver", "tomar", "conocer", "vivir", "sentir", "tratar", "mirar", "contar", "empezar", "esperar", "buscar", "existir", "entrar", "trabajar", "escribir", "perder", "producir", "ocurrir", "entender", "pedir", "recibir", "recordar", "terminar", "permitir", "aparecer", "conseguir", "comenzar", "servir", "sacar", "necesitar", "mantener", "resultar", "leer", "caer", "cambiar", "presentar", "crear", "abrir", "considerar", "o√≠r", "puede", "podr√≠a", "deber√≠a", "har√≠a", "ser√≠a", "estar√≠a", "tendr√≠a", "vendr√≠a"
        }
        
        # Limpiar texto
        text = re.sub(r'[^\w\s]', ' ', text.lower())
        words = text.split()
        
        # Filtrar palabras
        keywords = []
        for word in words:
            if (len(word) > 2 and 
                word not in stop_words and 
                not word.isdigit() and 
                word.isalpha()):
                keywords.append(word)
        
        return list(dict.fromkeys(keywords))
        
    def _generate_local_response(self, prompt: str) -> str:
        """Genera respuesta local"""
        keywords = self._extract_keywords(prompt)
        
        if not keywords:
            return "ü§î Hmm, necesito m√°s informaci√≥n para ayudarte mejor."
            
        # Respuestas espec√≠ficas para el metaverso
        metaverse_responses = {
            "metaverso": "üåê El metaverso es un espacio virtual 3D donde puedes interactuar, crear y explorar nuevos mundos digitales.",
            "avatar": "üë§ Los avatares son tu representaci√≥n digital en el metaverso. Puedes personalizarlos completamente.",
            "cripto": "‚Çø Las criptomonedas son la base econ√≥mica del metaverso, permitiendo transacciones seguras y descentralizadas.",
            "nft": "üñºÔ∏è Los NFTs son activos digitales √∫nicos que puedes poseer, intercambiar y usar en el metaverso.",
            "virtual": "üï∂Ô∏è La realidad virtual te permite sumergirte completamente en experiencias digitales inmersivas.",
            "3d": "üé® Los mundos 3D del metaverso ofrecen experiencias visuales y espaciales √∫nicas.",
            "juego": "üéÆ El metaverso combina gaming, socializaci√≥n y econom√≠a digital en una experiencia completa.",
            "social": "üë• Conecta con personas de todo el mundo en espacios virtuales compartidos.",
            "crear": "üõ†Ô∏è Construye y dise√±a tu propio espacio en el metaverso con herramientas creativas.",
            "explorar": "üó∫Ô∏è Descubre nuevos mundos, experiencias y comunidades en el metaverso."
        }
        
        # Buscar coincidencias
        for keyword in keywords:
            if keyword in metaverse_responses:
                return metaverse_responses[keyword]
                
        # Respuesta gen√©rica para la plataforma
        return f"üåü En el metaverso {config.platform.platform_name}, puedes explorar, crear y conectar en un mundo virtual 3D. ¬øTe gustar√≠a saber m√°s sobre alg√∫n aspecto espec√≠fico?"
        
    def _get_conversation_context(self, limit: int = 5) -> List[str]:
        """Obtiene contexto de conversaci√≥n reciente"""
        if not self.enable_memory:
            return []
            
        context = []
        for entry in list(self.conversation_history)[-limit:]:
            context.append(f"Usuario: {entry.user_input}")
            context.append(f"{self.name}: {entry.paraphrased_response}")
                
        return context
        
    def _store_response_in_memory(self, prompt: str, chat_response: ChatResponse):
        """Almacena la respuesta en memoria"""
        if not self.enable_memory:
            return
            
        # Crear entrada de memoria
        memory_entry = MemoryEntry(
            id=None,
            original_prompt=prompt,
            original_response=chat_response.original_response,
            paraphrased_response=chat_response.paraphrased_response,
            source_api=chat_response.source_api,
            timestamp=datetime.now(),
            confidence=chat_response.confidence,
            keywords=chat_response.keywords,
            context=chat_response.context,
            usage_count=0,
            effectiveness_score=0.5
        )
        
        # Almacenar en memoria con parafraseo de c√≥digo
        self.memory_manager.store_memory_entry(memory_entry, self.paraphraser)
        
        # Crear entrada de conversaci√≥n
        conversation_entry = ConversationEntry(
            id=None,
            user_input=prompt,
            lucia_response=chat_response.original_response,
            paraphrased_response=chat_response.paraphrased_response,
            timestamp=datetime.now(),
            source_api=chat_response.source_api,
            confidence=chat_response.confidence,
            processing_time=chat_response.processing_time,
            keywords=chat_response.keywords,
            context=chat_response.context
        )
        
        # Almacenar conversaci√≥n
        self.memory_manager.store_conversation(conversation_entry)
        self.conversation_history.append(conversation_entry)
        
    def _update_stats(self, chat_response: ChatResponse):
        """Actualiza estad√≠sticas"""
        self.stats["total_processing_time"] += chat_response.processing_time
        
        if chat_response.used_memory:
            self.stats["memory_requests"] += 1
        else:
            self.stats["api_requests"] += 1
            
        # Calcular confianza promedio
        total_requests = self.stats["total_requests"]
        current_avg = self.stats["average_confidence"]
        self.stats["average_confidence"] = ((current_avg * (total_requests - 1)) + chat_response.confidence) / total_requests
        
    def change_personality(self, new_personality: PersonalityType):
        """Cambia la personalidad de la IA"""
        old_personality = self.personality
        self.personality = new_personality
        
        # Actualizar paraphraser
        self.paraphraser = Paraphraser(ParaphraseConfig(
            personality=self.personality,
            confidence_threshold=config.memory.paraphrase_confidence
        ))
        
        return f"üé≠ Personalidad cambiada de {old_personality.value} a {new_personality.value}!"
        
    def get_stats(self) -> Dict[str, Any]:
        """Obtiene estad√≠sticas completas"""
        memory_stats = self.memory_manager.get_memory_stats() if self.memory_manager else {}
        
        return {
            "core_stats": self.stats,
            "memory_stats": memory_stats,
            "personality": self.personality.value,
            "name": self.name,
            "platform": config.platform.platform_name
        }
        
    def provide_feedback(self, feedback_type: str, rating: int = 0, comment: str = ""):
        """Permite al usuario proporcionar retroalimentaci√≥n"""
        if not self.conversation_history:
            return "No hay conversaciones recientes para evaluar."
            
        last_entry = self.conversation_history[-1]
        
        feedback_responses = {
            "positivo": "üòä ¬°Gracias por tu feedback positivo! Esto me ayuda a mejorar.",
            "negativo": "üòî Lamento no haber sido √∫til. Aprender√© de esto para mejorar.",
            "neutral": "ü§î Gracias por tu feedback. Seguir√© trabajando en mejorar mis respuestas."
        }
        
        return feedback_responses.get(feedback_type, "Gracias por tu retroalimentaci√≥n.")
        
    def export_conversation_history(self, format: str = "json") -> str:
        """Exporta el historial de conversaciones"""
        return self.memory_manager.export_memory(format) if self.memory_manager else "{}"
        
    def create_backup(self) -> str:
        """Crea un backup completo"""
        return self.memory_manager.create_backup() if self.memory_manager else "Backup no disponible"
        
    def cleanup_old_data(self, days: int = 30):
        """Limpia datos antiguos"""
        if self.memory_manager:
            self.memory_manager.cleanup_old_data(days)
        
    def search_conversations(self, query: str, limit: int = 10) -> List[Dict]:
        """Busca en el historial de conversaciones"""
        # Implementar b√∫squeda en memoria
        return []
        
    def reset_daily_limits(self):
        """Resetea los l√≠mites diarios de API"""
        # Limpiar contadores de uso diario
        if self.memory_manager:
            self.memory_manager.daily_usage.clear()
        return "üîÑ L√≠mites diarios de API reseteados" 